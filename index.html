<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mermaid to Draw.io Converter</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { padding: 20px; }
        .preview-container { min-height: 300px; border: 1px solid #ddd; padding: 20px; }
        #status { padding: 10px; margin: 10px 0; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="row mb-4">
            <div class="col">
                <h1>Mermaid to Draw.io Converter</h1>
                <p>Mermaidコードを入力して、Draw.io形式のファイルに変換します。</p>
            </div>
        </div>
        
        <div class="row mb-3">
            <div class="col">
                <label for="templateSelect" class="form-label">テンプレート:</label>
                <select id="templateSelect" class="form-select">
                    <option value="">テンプレートを選択</option>
                    <option value="flowchart">基本フローチャート</option>
                    <option value="sequence">シーケンス図</option>
                    <option value="gantt">ガントチャート</option>
                    <option value="class">クラス図</option>
                </select>
            </div>
        </div>
        
        <div class="row mb-3">
            <div class="col">
                <label for="mermaidInput" class="form-label">Mermaidコード:</label>
                <textarea id="mermaidInput" class="form-control" rows="10"></textarea>
            </div>
        </div>
        
        <div class="row mb-3">
            <div class="col">
                <button id="previewBtn" class="btn btn-primary">プレビュー表示</button>
                <button id="nativeBtn" class="btn btn-success ms-2">ネイティブ図形で生成</button>
            </div>
        </div>
        
        <div id="status" class="alert alert-info">テンプレートを選択するか、Mermaidコードを入力して「プレビュー表示」ボタンをクリックしてください。</div>
        
        <div class="row mb-4">
            <div class="col">
                <h3>プレビュー:</h3>
                <div id="preview-content" class="preview-container"></div>
            </div>
        </div>
        
        <div id="output-area" style="display:none">
            <h3>Draw.io XML:</h3>
            <textarea id="xml-output" class="form-control mb-3" rows="10"></textarea>
            <div class="mb-4">
                <button id="copyBtn" class="btn btn-primary">XMLをコピー</button>
                <button id="saveBtn" class="btn btn-success ms-2">ファイルとして保存</button>
            </div>
            <div class="alert alert-warning">
                <h4>使用方法:</h4>
                <ol>
                    <li>上記のXMLをコピーするか、ファイルとして保存します</li>
                    <li>ファイルをDraw.ioアプリで開くか、<a href="https://app.diagrams.net/" target="_blank">Draw.io Web版</a>にアップロード</li>
                    <li>Draw.ioで編集後、再度.drawioとして保存</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        // テンプレート定義
        const templates = {
            'flowchart': `graph TD
    A[開始] --> B{条件分岐}
    B -->|はい| C[処理1]
    B -->|いいえ| D[処理2]
    C --> E[結果1]
    D --> F[結果2]
    E --> G[終了]
    F --> G`,
            'sequence': `sequenceDiagram
    participant ユーザー
    participant システム
    participant データベース
    
    ユーザー->>システム: リクエスト送信
    システム->>データベース: データ検索
    データベース-->>システム: 結果返却
    システム-->>ユーザー: 応答表示`,
            'gantt': `gantt
    title プロジェクトスケジュール
    dateFormat  YYYY-MM-DD
    
    section 計画フェーズ
    要件定義           :a1, 2023-03-01, 10d
    設計               :a2, after a1, 15d
    
    section 開発フェーズ
    実装               :b1, after a2, 20d
    テスト             :b2, after b1, 10d`,
            'class': `classDiagram
    class User {
        +String name
        +String email
        +login()
        +logout()
    }
    
    class Product {
        +String name
        +Number price
        +getDetails()
    }
    
    User "1" --> "*" Order
    Order "*" --> "*" Product`
        };

        // Mermaidの初期化
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose'
        });

        // 要素取得
        const templateSelect = document.getElementById('templateSelect');
        const mermaidInput = document.getElementById('mermaidInput');
        const previewBtn = document.getElementById('previewBtn');
        const nativeBtn = document.getElementById('nativeBtn');
        const previewContent = document.getElementById('preview-content');
        const outputArea = document.getElementById('output-area');
        const xmlOutput = document.getElementById('xml-output');
        const copyBtn = document.getElementById('copyBtn');
        const saveBtn = document.getElementById('saveBtn');
        const statusEl = document.getElementById('status');

        // 現在のSVG内容
        let currentSvg = null;
        let lastMermaidCode = "";

        // ステータス表示関数
        function updateStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.className = isError ? 'alert alert-danger' : 'alert alert-success';
        }

        // テンプレート選択時の処理
        templateSelect.addEventListener('change', function() {
            if (this.value && templates[this.value]) {
                mermaidInput.value = templates[this.value];
            }
        });

        // プレビュー表示
        previewBtn.addEventListener('click', function() {
            updateStatus("Mermaidダイアグラムをレンダリングしています...");
            lastMermaidCode = mermaidInput.value;
            
            previewContent.innerHTML = '<div class="mermaid">' + lastMermaidCode + '</div>';
            
            try {
                mermaid.run()
                    .then(function() {
                        setTimeout(function() {
                            const svg = previewContent.querySelector('svg');
                            if (svg) {
                                currentSvg = svg.outerHTML;
                                outputArea.style.display = 'none';
                                updateStatus("✅ ダイアグラムのレンダリングが完了しました！");
                            } else {
                                updateStatus("エラー: SVG要素が見つかりません。", true);
                            }
                        }, 500);
                    })
                    .catch(function(error) {
                        updateStatus("エラー: " + error.message, true);
                    });
            } catch (error) {
                updateStatus("エラー: " + error.message, true);
            }
        });

        // メッセージタイプを検出する関数
        function detectMessageType(line) {
            if (line.includes('->>')) return { type: 'solid', separator: '->>' };
            if (line.includes('->')) return { type: 'solid', separator: '->' };
            if (line.includes('-->>')) return { type: 'dashed', separator: '-->>'}; 
            if (line.includes('-->')) return { type: 'dashed', separator: '-->'};
            return null;
        }

        // シーケンス図の解析
        function parseSequenceDiagram(code) {
            const lines = code.split('\n').map(line => line.trim()).filter(line => line);
            const participants = [];
            const messages = [];
            
            // 参加者とメッセージの解析
            lines.forEach(line => {
                if (line.startsWith('participant ')) {
                    participants.push(line.replace('participant ', '').trim());
                } else {
                    const messageType = detectMessageType(line);
                    if (messageType) {
                        const parts = line.split(messageType.separator);
                        if (parts && parts.length === 2) {
                            const source = parts[0].trim();
                            let target = parts[1].trim();
                            let text = '';
                            
                            if (target.includes(':')) {
                                const targetParts = target.split(':');
                                target = targetParts[0].trim();
                                text = targetParts.slice(1).join(':').trim();
                            }
                            
                            messages.push({
                                source,
                                target,
                                text,
                                isDashed: messageType.type === 'dashed'
                            });
                        }
                    }
                }
            });
            
            return { participants, messages };
        }

        // ネイティブ図形生成（シーケンス図）
        function generateSequenceNative(code) {
            const { participants, messages } = parseSequenceDiagram(code);
            
            // 現在の日時
            const currentTime = new Date().toISOString();
            
            // ユニークなID
            const uniqueId = 'native' + Math.random().toString(36).substr(2, 8);
            
            // Draw.io XMLを生成
            let xml = `<mxfile host="Electron" modified="${currentTime}" agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/26.0.9 Chrome/128.0.6613.186 Electron/32.2.5 Safari/537.36" version="26.0.9">
  <diagram name="Page-1" id="mermaid-sequence">
    <mxGraphModel dx="1306" dy="836" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        
        <!-- 参加者定義 -->`;
            
            // 参加者を追加
            participants.forEach((participant, index) => {
                const x = 40 + index * 200;
                xml += `
        <mxCell id="participant_${index}" value="${participant}" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="${x}" y="40" width="120" height="40" as="geometry" />
        </mxCell>`;
            });
            
            // 垂直ライン
            participants.forEach((participant, index) => {
                const x = 100 + index * 200;
                xml += `
        <mxCell id="line_${index}" value="" style="endArrow=none;dashed=1;html=1;strokeWidth=1;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="${x}" y="80" as="sourcePoint" />
            <mxPoint x="${x}" y="${80 + 40 + messages.length * 40}" as="targetPoint" />
          </mxGeometry>
        </mxCell>`;
            });
            
            // メッセージを追加
            messages.forEach((message, index) => {
                // 送信者と受信者のインデックスを取得
                const sourceIndex = participants.indexOf(message.source);
                const targetIndex = participants.indexOf(message.target);
                
                if (sourceIndex === -1 || targetIndex === -1) {
                    console.warn(`メッセージの送信者または受信者が見つかりません: ${message.source} -> ${message.target}`);
                    return;
                }
                
                const sourceX = 100 + sourceIndex * 200;
                const targetX = 100 + targetIndex * 200;
                const y = 120 + index * 40;

                // メッセージスタイル（実線または破線）
                const style = message.isDashed ? 
                    'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;' : 
                    'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;';
                
                xml += `
        <mxCell id="msg_${index}" value="${message.text}" style="${style}" edge="1" parent="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="${sourceX}" y="${y}" as="sourcePoint" />
            <mxPoint x="${targetX}" y="${y}" as="targetPoint" />
          </mxGeometry>
        </mxCell>`;
            });
            
            // フッターを追加
            participants.forEach((participant, index) => {
                const x = 40 + index * 200;
                const y = 80 + 40 + messages.length * 40;
                
                xml += `
        <mxCell id="footer_${index}" value="${participant}" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="${x}" y="${y}" width="120" height="40" as="geometry" />
        </mxCell>`;
            });
            
            // XMLを完成
            xml += `
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>`;
            
            return xml;
        }

        // フローチャートの解析
        function parseFlowchart(code) {
            const lines = code.split('\n').map(line => line.trim()).filter(line => line);
            const nodes = new Map();
            const connections = [];
            
            // ノード情報を抽出（フォーマット: A[label]）
            const nodeRegex = /([A-Za-z0-9_]+)(?:\[([^\]]+)\]|\(([^\)]+)\)|{([^}]+)})/g;
            const connectionRegex = /([A-Za-z0-9_]+)\s*--(?:-+)(?:>|&gt;)\s*(?:\|([^|]+)\|\s*)?([A-Za-z0-9_]+)/g;
            
            // ノードの検出
            lines.forEach(line => {
                let match;
                while ((match = nodeRegex.exec(line)) !== null) {
                    const id = match[1];
                    const label = match[2] || match[3] || match[4] || id;
                    const shape = match[2] ? 'rectangle' : (match[3] ? 'rounded' : 'rhombus');
                    
                    if (!nodes.has(id)) {
                        nodes.set(id, { id, label, shape });
                    }
                }
            });
            
            // 接続の検出
            lines.forEach(line => {
                let match;
                connectionRegex.lastIndex = 0;
                while ((match = connectionRegex.exec(line)) !== null) {
                    const source = match[1];
                    const label = match[2] || '';
                    const target = match[3];
                    
                    connections.push({ source, target, label });
                    
                    // 自動的にノードを追加（未定義の場合）
                    if (!nodes.has(source)) {
                        nodes.set(source, { id: source, label: source, shape: 'rectangle' });
                    }
                    if (!nodes.has(target)) {
                        nodes.set(target, { id: target, label: target, shape: 'rectangle' });
                    }
                }
            });
            
            return { nodes: Array.from(nodes.values()), connections };
        }

        // ネイティブ図形生成（フローチャート）
        function generateFlowchartNative(code) {
            const { nodes, connections } = parseFlowchart(code);
            
            // 現在の日時
            const currentTime = new Date().toISOString();
            
            // ユニークなID
            const uniqueId = 'native' + Math.random().toString(36).substr(2, 8);
            
            // レイアウト計算（簡易版）
            let grid = {};
            let maxRow = 0;
            let maxCol = 0;
            
            // 簡易的なレイアウト計算（深さ優先探索）
            function calculateLayout() {
                const visited = new Set();
                
                function dfs(nodeId, row, col) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    
                    grid[nodeId] = { row, col };
                    maxRow = Math.max(maxRow, row);
                    maxCol = Math.max(maxCol, col);
                    
                    let childCol = col;
                    const children = connections.filter(conn => conn.source === nodeId).map(conn => conn.target);
                    
                    children.forEach((childId, index) => {
                        dfs(childId, row + 1, col + index);
                        childCol = col + index + 1;
                    });
                }
                
                // 最初のノードから開始
                if (nodes.length > 0) {
                    dfs(nodes[0].id, 0, 0);
                }
                
                // 未訪問のノードを処理
                nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        maxCol++;
                        dfs(node.id, 0, maxCol);
                    }
                });
            }
            
            calculateLayout();
            
            // Draw.io XMLを生成
            let xml = `<mxfile host="Electron" modified="${currentTime}" agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/26.0.9 Chrome/128.0.6613.186 Electron/32.2.5 Safari/537.36" version="26.0.9">
  <diagram name="Page-1" id="mermaid-flowchart">
    <mxGraphModel dx="1306" dy="836" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        
        <!-- ノード定義 -->`;
            
            // ノードを追加
            nodes.forEach(node => {
                const pos = grid[node.id] || { row: 0, col: 0 };
                const x = 50 + pos.col * 150;
                const y = 50 + pos.row * 100;
                
                let style = "";
                
                switch (node.shape) {
                    case 'rectangle':
                        style = "rounded=0;whiteSpace=wrap;html=1;";
                        break;
                    case 'rounded':
                        style = "rounded=1;whiteSpace=wrap;html=1;";
                        break;
                    case 'rhombus':
                        style = "rhombus;whiteSpace=wrap;html=1;";
                        break;
                    default:
                        style = "rounded=0;whiteSpace=wrap;html=1;";
                }
                
                xml += `
        <mxCell id="node_${node.id}" value="${node.label}" style="${style}" vertex="1" parent="1">
          <mxGeometry x="${x}" y="${y}" width="120" height="60" as="geometry" />
        </mxCell>`;
            });
            
            // 接続を追加
            connections.forEach((conn, index) => {
                xml += `
        <mxCell id="conn_${index}" value="${conn.label}" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="1" source="node_${conn.source}" target="node_${conn.target}">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>`;
            });
            
            // XMLを完成
            xml += `
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>`;
            
            return xml;
        }

        // ネイティブ図形生成ボタン
        nativeBtn.addEventListener('click', function() {
            if (!lastMermaidCode) {
                updateStatus("Mermaidコードを入力して先にプレビューを表示してください。", true);
                return;
            }

            updateStatus("ネイティブ図形のDraw.io XML形式に変換しています...");
            
            try {
                let drawioXml = "";
                
                // ダイアグラムタイプに応じた変換処理
                if (lastMermaidCode.trim().startsWith('sequenceDiagram')) {
                    drawioXml = generateSequenceNative(lastMermaidCode);
                } else if (lastMermaidCode.trim().startsWith('graph')) {
                    drawioXml = generateFlowchartNative(lastMermaidCode);
                } else {
                    updateStatus("このタイプのダイアグラムは現在サポートされていません。", true);
                    return;
                }
                
                // XMLを表示
                xmlOutput.value = drawioXml;
                outputArea.style.display = 'block';
                
                updateStatus("✅ Draw.io XML生成が完了しました！（ネイティブ図形版）");
            } catch (error) {
                console.error(error);
                updateStatus("エラー: " + error.message, true);
            }
        });

        // コピーボタン
        copyBtn.addEventListener('click', function() {
            xmlOutput.select();
            document.execCommand('copy');
            updateStatus("✅ XMLをクリップボードにコピーしました！");
        });

        // 保存ボタン
        saveBtn.addEventListener('click', function() {
            const blob = new Blob([xmlOutput.value], {type: 'application/xml'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'diagram.drawio';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            updateStatus("✅ diagram.drawioとして保存しました！");
        });

        // 初期化時のデフォルトコード設定
        mermaidInput.value = templates['sequence'];
    </script>
</body>
</html>
